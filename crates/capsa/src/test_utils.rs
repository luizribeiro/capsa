//! Test utilities for Capsa integration tests and benchmarks.
//!
//! This module provides helpers for loading test VM configurations from the
//! manifest generated by `test-vms.nix`.

use crate::pool::Yes;
use crate::{
    Capsa, DiskImage, LinuxDirectBootConfig, LinuxVmBuilder, UefiBootConfig, UefiVmBuilder,
};
use serde::Deserialize;
use std::collections::HashMap;
use std::path::PathBuf;
use std::sync::OnceLock;

/// Message printed by UEFI test VMs on successful boot.
/// Keep in sync with test-vms.nix mkUefiInitScript.
pub const UEFI_BOOT_SUCCESS_MESSAGE: &str = "UEFI Boot successful";

#[derive(Debug, Deserialize)]
pub struct VmPaths {
    pub kernel: PathBuf,
    pub initrd: PathBuf,
    #[serde(default)]
    pub disk: Option<PathBuf>,
    #[serde(default)]
    pub is_uefi: bool,
}

type VmManifest = HashMap<String, VmPaths>;

static VM_MANIFEST: OnceLock<Option<VmManifest>> = OnceLock::new();

fn load_manifest() -> &'static VmManifest {
    VM_MANIFEST
        .get_or_init(|| {
            let manifest_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
                .parent()
                .expect("Failed to get parent directory")
                .parent()
                .expect("Failed to get project root")
                .join("result-vms")
                .join("manifest.json");

            let content = std::fs::read_to_string(&manifest_path).expect(
                "Failed to read test VM manifest. Run 'nix-build test-vms.nix -o result-vms'",
            );
            Some(serde_json::from_str(&content).expect("Failed to parse test VM manifest"))
        })
        .as_ref()
        .expect("Manifest should be loaded")
}

/// Returns the paths for a test VM from the manifest.
pub fn vm_paths(name: &str) -> &'static VmPaths {
    let manifest = load_manifest();
    manifest
        .get(name)
        .unwrap_or_else(|| panic!("Unknown test VM: {name}. Available: {:?}", manifest.keys()))
}

fn boot_config(name: &str) -> LinuxDirectBootConfig {
    let paths = vm_paths(name);

    if !paths.kernel.exists() {
        panic!("Kernel not found at {:?}", paths.kernel);
    }
    if !paths.initrd.exists() {
        panic!("Initrd not found at {:?}", paths.initrd);
    }

    let mut config = LinuxDirectBootConfig::new(&paths.kernel, &paths.initrd);

    if let Some(disk_path) = &paths.disk {
        if !disk_path.exists() {
            panic!("Disk not found at {:?}", disk_path);
        }
        // Default to read-only since disk images are typically in the Nix store
        config = config.with_root_disk(DiskImage::new(disk_path).read_only());
    }

    config
}

/// Returns a VM builder for the given test VM name with console enabled.
///
/// Available VMs:
/// - `"default"` - Full-featured VM with networking
/// - `"no-network"` - Minimal VM without networking
///
/// # Panics
///
/// Panics if the test VMs haven't been built. This should not happen
/// as `build.rs` auto-builds them, but if it does, run:
/// `nix-build test-vms.nix -o result-vms`
pub fn test_vm(name: &str) -> LinuxVmBuilder {
    let config = boot_config(name);
    let builder = Capsa::vm(config).console_enabled();
    // TODO: Enable networking once KVM backend supports NAT
    #[cfg(feature = "linux-kvm")]
    let builder = builder.no_network();
    builder
}

/// Convenience function for the default test VM (with networking).
pub fn default_test_vm() -> LinuxVmBuilder {
    test_vm("default")
}

/// Returns a pool builder for the given test VM name with console enabled.
///
/// Use this instead of [`test_vm`] when you need to create a VM pool.
pub fn test_pool(name: &str) -> LinuxVmBuilder<Yes> {
    let config = boot_config(name);
    let builder = Capsa::pool(config).console_enabled();
    // TODO: Enable networking once KVM backend supports NAT
    #[cfg(feature = "linux-kvm")]
    let builder = builder.no_network();
    builder
}

fn uefi_boot_config(name: &str) -> UefiBootConfig {
    let paths = vm_paths(name);

    if !paths.is_uefi {
        panic!("VM {name} is not a UEFI VM");
    }

    let disk_path = paths
        .disk
        .as_ref()
        .unwrap_or_else(|| panic!("UEFI VM {name} has no disk path"));

    if !disk_path.exists() {
        panic!("Disk not found at {:?}", disk_path);
    }

    UefiBootConfig::new(DiskImage::new(disk_path).read_only())
}

/// Returns a UEFI VM builder for the given test VM name with console enabled.
///
/// Available UEFI VMs:
/// - `"uefi"` - UEFI-bootable VM with EFI stub kernel
///
/// # Panics
///
/// Panics if the test VMs haven't been built or if the VM is not a UEFI VM.
pub fn test_uefi_vm(name: &str) -> UefiVmBuilder {
    let config = uefi_boot_config(name);
    Capsa::vm(config).console_enabled()
}

/// Returns a UEFI pool builder for the given test VM name with console enabled.
pub fn test_uefi_pool(name: &str) -> UefiVmBuilder<Yes> {
    let config = uefi_boot_config(name);
    Capsa::pool(config).console_enabled()
}
