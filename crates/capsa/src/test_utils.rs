//! Test utilities for Capsa integration tests and benchmarks.
//!
//! This module provides helpers for loading test VM configurations from the
//! manifest generated by `nix/test-vms`.

use crate::pool::Yes;
use crate::{
    Capsa, DiskImage, LinuxDirectBootConfig, LinuxVmBuilder, UefiBootConfig, UefiVmBuilder,
};
use serde::Deserialize;
use std::collections::HashMap;
use std::path::PathBuf;
use std::sync::OnceLock;

/// Message printed by test VMs on successful boot.
/// Keep in sync with nix/test-vms/lib.nix mkInitScript.
pub const BOOT_SUCCESS_MESSAGE: &str = "Boot successful";

#[derive(Debug, Deserialize)]
pub struct VmPaths {
    pub kernel: PathBuf,
    pub initrd: PathBuf,
    #[serde(default)]
    pub disk: Option<PathBuf>,
    #[serde(default)]
    pub is_uefi: bool,
}

type VmManifest = HashMap<String, VmPaths>;

static VM_MANIFEST: OnceLock<Option<VmManifest>> = OnceLock::new();

fn result_vms_dir() -> PathBuf {
    PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .expect("Failed to get parent directory")
        .parent()
        .expect("Failed to get project root")
        .join("result-vms")
}

fn load_manifest() -> &'static VmManifest {
    VM_MANIFEST
        .get_or_init(|| {
            let result_vms = result_vms_dir();
            let manifest_path = result_vms.join("manifest.json");

            let content = std::fs::read_to_string(&manifest_path).expect(
                "Failed to read test VM manifest. Run 'nix-build nix/test-vms -A aarch64.combined -o result-vms'",
            );
            let mut manifest: VmManifest =
                serde_json::from_str(&content).expect("Failed to parse test VM manifest");

            // Resolve relative paths in manifest to absolute paths
            for paths in manifest.values_mut() {
                if paths.kernel.is_relative() {
                    paths.kernel = result_vms.join(&paths.kernel);
                }
                if paths.initrd.is_relative() {
                    paths.initrd = result_vms.join(&paths.initrd);
                }
                if let Some(disk) = &paths.disk {
                    if disk.is_relative() {
                        paths.disk = Some(result_vms.join(disk));
                    }
                }
            }

            Some(manifest)
        })
        .as_ref()
        .expect("Manifest should be loaded")
}

/// Returns the paths for a test VM from the manifest.
pub fn vm_paths(name: &str) -> &'static VmPaths {
    let manifest = load_manifest();
    manifest
        .get(name)
        .unwrap_or_else(|| panic!("Unknown test VM: {name}. Available: {:?}", manifest.keys()))
}

fn boot_config(name: &str) -> LinuxDirectBootConfig {
    let paths = vm_paths(name);

    if !paths.kernel.exists() {
        panic!("Kernel not found at {:?}", paths.kernel);
    }
    if !paths.initrd.exists() {
        panic!("Initrd not found at {:?}", paths.initrd);
    }

    let mut config = LinuxDirectBootConfig::new(&paths.kernel, &paths.initrd);

    if let Some(disk_path) = &paths.disk {
        if !disk_path.exists() {
            panic!("Disk not found at {:?}", disk_path);
        }
        // Default to read-only since disk images are typically in the Nix store
        config = config.with_root_disk(DiskImage::new(disk_path).read_only());
    }

    config
}

/// Returns a VM builder for the given test VM name with console enabled.
///
/// Available VMs:
/// - `"default"` - Universal VM with networking, disk, and vsock support
/// - `"with-disk"` - Same as default, but includes a pre-created disk image
/// - `"uefi"` - UEFI-bootable VM (use `test_uefi_vm` instead)
///
/// # Panics
///
/// Panics if the test VMs haven't been built. This should not happen
/// as `build.rs` auto-builds them, but if it does, run:
/// `nix-build nix/test-vms -A aarch64.combined -o result-vms`
pub fn test_vm(name: &str) -> LinuxVmBuilder {
    let config = boot_config(name);
    let builder = Capsa::vm(config).console_enabled();
    // TODO: Enable networking once KVM backend supports NAT
    #[cfg(feature = "linux-kvm")]
    let builder = builder.no_network();
    builder
}

/// Convenience function for the default test VM (with networking).
pub fn default_test_vm() -> LinuxVmBuilder {
    test_vm("default")
}

/// Returns a pool builder for the given test VM name with console enabled.
///
/// Use this instead of [`test_vm`] when you need to create a VM pool.
pub fn test_pool(name: &str) -> LinuxVmBuilder<Yes> {
    let config = boot_config(name);
    let builder = Capsa::pool(config).console_enabled();
    // TODO: Enable networking once KVM backend supports NAT
    #[cfg(feature = "linux-kvm")]
    let builder = builder.no_network();
    builder
}

fn uefi_boot_config(name: &str) -> UefiBootConfig {
    let paths = vm_paths(name);

    if !paths.is_uefi {
        panic!("VM {name} is not a UEFI VM");
    }

    let disk_path = paths
        .disk
        .as_ref()
        .unwrap_or_else(|| panic!("UEFI VM {name} has no disk path"));

    if !disk_path.exists() {
        panic!("Disk not found at {:?}", disk_path);
    }

    UefiBootConfig::new(DiskImage::new(disk_path).read_only())
}

/// Returns a UEFI VM builder for the given test VM name with console enabled.
///
/// Available UEFI VMs:
/// - `"uefi"` - UEFI-bootable VM with EFI stub kernel
///
/// # Panics
///
/// Panics if the test VMs haven't been built or if the VM is not a UEFI VM.
pub fn test_uefi_vm(name: &str) -> UefiVmBuilder {
    let config = uefi_boot_config(name);
    Capsa::vm(config).console_enabled()
}

/// Returns a UEFI pool builder for the given test VM name with console enabled.
pub fn test_uefi_pool(name: &str) -> UefiVmBuilder<Yes> {
    let config = uefi_boot_config(name);
    Capsa::pool(config).console_enabled()
}
